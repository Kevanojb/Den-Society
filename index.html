<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Den Society — League & Eclectic</title>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Supabase UMD -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.min.js"></script>

    <!-- Babel for JSX-in-browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body{font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial}
      table th, table td { padding:.5rem .6rem; }
    </style>
  </head>

  <body class="bg-neutral-50 text-neutral-900">
    <div id="root"></div>

    <script type="text/babel" data-presets="react">
      /* global React, ReactDOM, supabase */
      const { useState, useEffect, useMemo } = React;

      // ---------- helpers ----------
      const POINTS_TABLE = [20,17,15,13,11,9,8,7,6,5,4,3,2,1];
      const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
      const csvEscape = s => {
        if (s==null) return "";
        const str=String(s);
        return /[",\n]/.test(str) ? '"' + str.replace(/"/g,'""') + '"' : str;
      };
      const downloadCSV = (filename, rows) => {
        const csv = rows.map(r=>r.map(csvEscape).join(",")).join("\n");
        const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
        const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=filename; a.click();
      };

      function playingCapByGender(g){ return g==="F"?36:28; }
      function rangeForHcap(h){ if(h<=9)return"0-9"; if(h<=18)return"10-18"; if(h<=28)return"19-28"; return"29-36"; }
      function cutPerPointOver34(h){ const r=rangeForHcap(h); return r==="0-9"?0.5:r==="10-18"?1:r==="19-28"?1:1.5; }
      function winnerBonusCut(h){ const r=rangeForHcap(h); return r==="0-9"?1:r==="10-18"?2:r==="19-28"?2.5:3; }
      function computeNewExactHandicap(start,g,pts,b9,w){
        const startPlay=Math.round(start); let exact=start;
        if(pts>=35){ exact-=cutPerPointOver34(startPlay)*(pts-34); }
        else if(pts<=31){ exact+=0.5*(32-pts); }
        if(w) exact-=winnerBonusCut(startPlay);
        const max=playingCapByGender(g); const bounded=clamp(exact,0,60); const nextPlay=clamp(Math.round(bounded),0,max);
        return {nextExact:bounded,nextPlaying:nextPlay};
      }

      // ---------- robust parser (prevents duplicates & wrong totals) ----------
      function parseSquabbitCSV(text){
        const rows = text.replace(/\r/g,'').split('\n').filter(Boolean);
        const splitRow = raw => (raw.includes('\t') ? raw.split('\t') : raw.split(','))
          .map(s => (s||'').replace(/^"|"$/g,'').trim());
        const lines = rows.map(splitRow);

        const nnum = x => {
          const v = parseFloat(String(x||'').replace(/[^0-9.\-]/g,''));
          return Number.isFinite(v) ? v : 0;
        };

        // --- PATH A: Simple CSV headers
        const header = (lines[0]||[]).map(h => h.toLowerCase());
        const idx = h => header.indexOf(h);
        const hasSimple =
          idx('name')>=0 && idx('hdcp')>=0 && idx('stableford')>=0 &&
          (idx('h1')>=0 && idx('h18')>=0);

        if (hasSimple){
          const iH1 = idx('h1'), iH18 = idx('h18');
          const out = [];
          const seen = new Set(); // de-dupe by name
          for (let i=1;i<lines.length;i++){
            const r = lines[i];
            const nm = r[idx('name')];
            if (!nm || seen.has(nm)) continue;
            seen.add(nm);
            const perHole = [];
            for (let c=iH1;c<=iH18;c++) perHole.push(nnum(r[c]));
            out.push({
              name: nm,
              gender: 'M',
              handicap: nnum(r[idx('hdcp')]),
              points: nnum(r[idx('stableford')]),
              back9: nnum(idx('back9')>=0 ? r[idx('back9')] : perHole.slice(9).reduce((a,b)=>a+b,0)),
              perHole,
              eventMaxHole: perHole.length ? Math.max(...perHole) : 0
            });
          }
          return out;
        }

        // --- PATH B: Squabbit export
        // 1) Players list (de-dupe by name)
        const players = [];
        const seenNames = new Set();
        const playerHeaderRow = lines.findIndex(r => (r[0]||'')==='Name' && (r[1]||'')==='Hdcp');
        if (playerHeaderRow >= 0){
          for (let i=playerHeaderRow+1;i<lines.length;i++){
            const name=(lines[i][0]||'').trim();
            const hcap=nnum(lines[i][1]);
            if (!name) break;
            if (!seenNames.has(name) && !Number.isNaN(hcap)) {
              seenNames.add(name);
              players.push({name,handicap:hcap,gender:'M'});
            }
          }
        }

        // 2) Choose the "real" Stableford totals section (avoid the tiny-number table)
        const stablefordIdxs = lines
          .map((r,ix)=> ({ix, row:r}))
          .filter(x => (x.row[0]||'').trim()==='Stableford');

        let totalsStart = -1;
        for (const cand of stablefordIdxs){
          const hdr = lines[cand.ix+1] || [];
          const looksLikeHeader = (hdr[0]||'').toLowerCase()==='player';
          // Heuristic: in the next ~20 rows, most totals should be >= 15
          let bigCount = 0, rowsChecked = 0;
          for (let i=cand.ix+2; i<Math.min(lines.length, cand.ix+22); i++){
            const nm = (lines[i][0]||'').trim();
            if (!nm) break;
            const val = nnum(lines[i][1]);
            if (val>=15) bigCount++;
            rowsChecked++;
          }
          if (looksLikeHeader && rowsChecked>=5 && bigCount/rowsChecked >= 0.6){
            totalsStart = cand.ix;
            break;
          }
        }

        const totals = {};
        if (totalsStart>=0){
          for (let i=totalsStart+2;i<lines.length;i++){
            const name=(lines[i][0]||'').trim();
            if (!name) break;
            const total = nnum(lines[i][1]);
            if (name && Number.isFinite(total)) totals[name]=total;
          }
        }

        // 3) Per-hole via row after name where col B === 'Stableford'
        const holeData = {};
        for (const p of players){
          for (let i=0;i<lines.length-1;i++){
            const rowA = lines[i]||[];
            const rowB = lines[i+1]||[];
            if ((rowA[0]||'').trim() === p.name && (rowB[1]||'').trim() === 'Stableford'){
              // preferred windows: D..L (H1..H9), N..V (H10..H18)
              const front9 = rowB.slice(3,12).map(nnum);
              const back9H = rowB.slice(13,22).map(nnum);

              let perHole = [];
              if (front9.length===9 && back9H.length===9 &&
                  (front9.some(v=>v>0) || back9H.some(v=>v>0))) {
                perHole = [...front9, ...back9H];
              } else {
                // fallback: first 18 numeric cells, but only if there are at least 12 non-zeros
                const numeric = rowB.map(nnum).filter(v => Number.isFinite(v));
                const candidate = numeric.slice(0,18);
                const nz = candidate.filter(v=>v>0).length;
                if (candidate.length===18 && nz>=12) perHole = candidate;
              }

              // sanity check back9
              const back9 = perHole.slice(9).reduce((a,b)=>a+b,0);
              if (perHole.length===18 && back9<=27 && back9>=0){
                holeData[p.name] = { perHole, back9, maxHole: Math.max(...perHole) };
              }
              break;
            }
          }
        }

        // 4) Build final player list
        const out = [];
        const finalSeen = new Set();
        for (const p of players){
          if (finalSeen.has(p.name)) continue;
          finalSeen.add(p.name);
          out.push({
            name: p.name,
            gender: p.gender,
            handicap: p.handicap,
            points: totals[p.name] || 0,
            back9: holeData[p.name]?.back9 || 0,
            perHole: holeData[p.name]?.perHole || [],
            eventMaxHole: holeData[p.name]?.maxHole || 0
          });
        }
        return out;
      }

      function mergeEclectic(prev,currentPerHole){
        const bestPerHole=Array.from({length:18},(_,i)=>Math.max(prev?.[i]??0,currentPerHole?.[i]??0));
        const eclecticTotal=bestPerHole.reduce((s,v)=>s+(isFinite(v)?v:0),0);
        return {bestPerHole,eclecticTotal};
      }

      function makeSupabaseClient(url,key){
        try{
          if(!url||!key) return null;
          return supabase.createClient(url,key);
        }catch(e){
          console.warn("Supabase client failed", e);
          return null;
        }
      }

      // ---------- App ----------
      function App(){
        const [players,setPlayers]=useState([]);
        const [computed,setComputed]=useState([]);
        const [season,setSeason]=useState({});
        const [eventName,setEventName]=useState("Den Society Meeting");
        const [dateStr,setDateStr]=useState(()=>new Date().toISOString().slice(0,10));

        // Your Supabase defaults
        const defaultURL = "https://mqknahdfpqxrpgpxqtus.supabase.co";
        const defaultKEY = "sb_publishable_mTokuyCyHWPCl83L9qL0lQ_IP2TBWFt";

        const [supaURL,setSupaURL]=useState(localStorage.getItem('supa_url')||defaultURL);
        const [supaKEY,setSupaKEY]=useState(localStorage.getItem('supa_key')||defaultKEY);
        const [client,setClient]=useState(makeSupabaseClient(supaURL.trim(),supaKEY.trim()));
        const connected=!!client;

        async function saveSupa(){
          localStorage.setItem('supa_url',supaURL.trim());
          localStorage.setItem('supa_key',supaKEY.trim());
          setClient(makeSupabaseClient(supaURL.trim(),supaKEY.trim()));
        }

        async function fetchSeason(){
          if(!client) return;
          const {data,error}=await client
            .from('season_standings')
            .select('name,total_points,events,best_event_points,best_hole_points,eclectic_total,best_per_hole')
            .order('total_points',{ascending:false});
          if(error){ console.warn('Supabase fetch error', error); return; }
          const map={};
          (data||[]).forEach(r=>{
            map[r.name]={
              name:r.name,
              totalPoints:r.total_points||0,
              events:r.events||0,
              bestEventPoints:r.best_event_points??0,
              bestHolePoints:r.best_hole_points??0,
              eclecticTotal:r.eclectic_total??0,
              bestPerHole:Array.isArray(r.best_per_hole)?r.best_per_hole:
                (typeof r.best_per_hole==='string'?JSON.parse(r.best_per_hole||'[]'):[])
            };
          });
          setSeason(map);
        }
        useEffect(()=>{ fetchSeason(); },[client]);

        async function importCSV(file){ const text=await file.text(); setPlayers(parseSquabbitCSV(text)); }

        useMemo(()=>{
          const rows=players.map((p,i)=>({idx:i,name:p.name,gender:p.gender,startExact:p.handicap,points:p.points,back9:p.back9,perHole:p.perHole}));
          const base=[...rows].sort((a,b)=>(b.points-a.points)||(b.back9-a.back9));
          if(!base.length){ setComputed([]); return; }

          // tie groups: all tied players get the highest available slot points
          const groups=[]; const used=new Set();
          for(let i=0;i<base.length;i++){
            if(used.has(base[i].idx)) continue;
            const grp=base.filter(r=>r.points===base[i].points).map(r=>r.idx);
            grp.forEach(id=>used.add(id)); groups.push(grp);
          }

          let pos=1; const out=[]; const winnerIdx=base[0].idx;
          for(const g of groups){
            const start=pos;
            const ptsValue=POINTS_TABLE[start-1]||0;
            for(const i of g){
              const r=rows.find(x=>x.idx===i);
              const res=computeNewExactHandicap(r.startExact,r.gender,r.points,r.back9,i===winnerIdx);
              out.push({...r,position:start,leaguePoints:ptsValue,isWinner:i===winnerIdx,...res});
            }
            pos+=g.length;
          }
          setComputed(out.sort((a,b)=>a.position-b.position));
        },[players]);

        async function addEventToSeason(){
          const next={...season};
          for(const r of computed){
            const prev=next[r.name]||{name:r.name,totalPoints:0,events:0,bestPerHole:Array(18).fill(0),eclecticTotal:0,bestEventPoints:0,bestHolePoints:0};
            const {bestPerHole,eclecticTotal}=mergeEclectic(prev.bestPerHole,r.perHole||[]);
            const nextBestEvent=Math.max(prev.bestEventPoints||0,r.points||0);
            const nextBestHole=Math.max(prev.bestHolePoints||0,Math.max(0,...(r.perHole||[])));
            next[r.name]={
              name:r.name,
              totalPoints:(prev.totalPoints||0)+(r.leaguePoints||0),
              events:(prev.events||0)+1,
              bestEventPoints:nextBestEvent,
              bestHolePoints:nextBestHole,
              bestPerHole, eclecticTotal
            };
          }
          setSeason(next);

          if(client){
            const rows=Object.values(next).map(r=>({
              name:r.name,
              total_points:r.totalPoints,
              events:r.events,
              best_event_points:r.bestEventPoints??0,
              best_hole_points:r.bestHolePoints??0,
              eclectic_total:r.eclecticTotal??0,
              best_per_hole:(r.bestPerHole??Array(18).fill(0)),
            }));
            const {error}=await client.from('season_standings').upsert(rows,{onConflict:'name'});
            if(error) console.warn('Supabase upsert error', error);
            await fetchSeason();
          }
        }

        function exportStandings(){
          const list=Object.values(season).sort((a,b)=>(b.totalPoints-a.totalPoints)||a.name.localeCompare(b.name));
          const rows=[["Rank","Name","Events","Total Points","Best Event","Best Hole","Eclectic Total"],
            ...list.map((r,i)=>[i+1,r.name,r.events,r.totalPoints,r.bestEventPoints??0,r.bestHolePoints??0,r.eclecticTotal??0])
          ];
          downloadCSV(`DenSociety_Standings_${dateStr.replace(/-/g,'')}.csv`,rows);
        }

        function exportEclecticCSV(){
          const list=Object.values(season).sort((a,b)=>(b.eclecticTotal??0)-(a.eclecticTotal??0)||a.name.localeCompare(b.name));
          const header=["Rank","Name","Eclectic Total",...Array.from({length:18},(_,i)=>`H${i+1}`)];
          const rows=[header, ...list.map((r,i)=>[i+1,r.name,r.eclecticTotal??0,...(r.bestPerHole??Array(18).fill(0))])];
          downloadCSV(`DenSociety_Eclectic_${dateStr.replace(/-/g,'')}.csv`,rows);
        }

        function resetSeason(){ setSeason({}); } // local reset only

        return (
          <div className="min-h-screen p-4 sm:p-6 md:p-8">
            <div className="max-w-6xl mx-auto space-y-6">
              <header className="flex flex-col md:flex-row md:items-end gap-3 justify-between">
                <div>
                  <h1 className="text-2xl md:text-3xl font-bold tracking-tight">Den Society — League & Eclectic</h1>
                  <p className="text-sm text-neutral-600">{connected ? '✅ Supabase connected' : '❌ Supabase not configured'}</p>
                </div>
                <div className="flex gap-2 items-center">
                  <input className="px-3 py-2 rounded-xl border border-neutral-300 bg-white" value={eventName} onChange={e=>setEventName(e.target.value)} />
                  <input type="date" className="px-3 py-2 rounded-xl border border-neutral-300 bg-white" value={dateStr} onChange={e=>setDateStr(e.target.value)} />
                </div>
              </header>

              {/* Settings */}
              <section className="bg-white rounded-2xl shadow-sm p-4 md:p-6">
                <h2 className="text-lg font-semibold mb-2">Settings</h2>
                <div className="grid md:grid-cols-2 gap-3">
                  <div>
                    <label className="text-sm block mb-1">Supabase URL</label>
                    <input className="w-full px-3 py-2 rounded-xl border border-neutral-300 bg-white" placeholder="https://xxxx.supabase.co" value={supaURL} onChange={e=>setSupaURL(e.target.value)} />
                  </div>
                  <div>
                    <label className="text-sm block mb-1">Supabase publishable key</label>
                    <input className="w-full px-3 py-2 rounded-xl border border-neutral-300 bg-white" placeholder="sb_..." value={supaKEY} onChange={e=>setSupaKEY(e.target.value)} />
                  </div>
                </div>
                <div className="mt-3 flex flex-wrap gap-2">
                  <button onClick={saveSupa} className="px-3 py-2 rounded-xl bg-emerald-600 text-white">Save & Connect</button>
                  <button onClick={fetchSeason} className="px-3 py-2 rounded-xl border border-neutral-300">Reload Season</button>
                </div>
                <p className="text-xs text-neutral-500 mt-2">Publishable key is fine in browser if your table uses RLS policies.</p>
              </section>

              {/* Import + Event table */}
              <section className="bg-white rounded-2xl shadow-sm p-4 md:p-6">
                <div className="flex justify-between mb-4">
                  <h2 className="text-lg font-semibold">Event Players</h2>
                  <div className="flex flex-wrap gap-2">
                    <label className="px-3 py-2 rounded-xl border border-neutral-300 bg-white cursor-pointer">Import CSV
                      <input type="file" accept=".csv" className="hidden" onChange={e=>{const f=e.target.files?.[0]; if(f) importCSV(f);}} />
                    </label>
                    <button onClick={addEventToSeason} disabled={!players.length} className="px-3 py-2 rounded-xl bg-emerald-600 text-white disabled:opacity-40">Add Event → Season</button>
                    <button onClick={()=>setPlayers([])} className="px-3 py-2 rounded-xl border border-neutral-300">Clear Event</button>
                  </div>
                </div>
                <div className="overflow-auto">
                  <table className="min-w-full text-sm">
                    <thead>
                      <tr className="border-b text-left"><th>#</th><th>Name</th><th>Handicap</th><th>Stableford</th><th>Back9</th><th>Pts</th><th>Next PH</th></tr>
                    </thead>
                    <tbody>
                      {computed.map((r,i)=>(
                        <tr key={i} className="border-b">
                          <td>{r.position}</td>
                          <td>{r.name}</td>
                          <td>{Math.round(r.startExact)}</td>
                          <td>{r.points}</td>
                          <td>{r.back9}</td>
                          <td>{r.leaguePoints}</td>
                          <td>{r.nextPlaying}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                <p className="text-xs text-neutral-500 mt-2">Ties share the highest available slot points (e.g., joint 2nd both get 17; next is 4th).</p>
              </section>

              {/* Season standings */}
              <section className="bg-white rounded-2xl shadow-sm p-4 md:p-6">
                <div className="flex justify-between mb-4">
                  <h2 className="text-lg font-semibold">Season Standings</h2>
                  <div className="flex gap-2">
                    <button onClick={exportStandings} className="px-3 py-2 rounded-xl bg-black text-white">Export Standings</button>
                  </div>
                </div>
                <div className="overflow-auto">
                  <table className="min-w-full text-sm">
                    <thead>
                      <tr className="border-b text-left">
                        <th>Rank</th><th>Name</th><th>Events</th><th>Total Points</th><th>Best Event</th><th>Best Hole</th><th>Eclectic Total</th>
                      </tr>
                    </thead>
                    <tbody>
                      {Object.values(season).sort((a,b)=> (b.totalPoints-a.totalPoints)||a.name.localeCompare(b.name)).map((r,i)=>(
                        <tr key={r.name} className="border-b">
                          <td>{i+1}</td>
                          <td>{r.name}</td>
                          <td>{r.events}</td>
                          <td>{r.totalPoints}</td>
                          <td>{r.bestEventPoints??0}</td>
                          <td>{r.bestHolePoints??0}</td>
                          <td>{r.eclecticTotal??0}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </section>

              {/* Eclectic */}
              <section className="bg-white rounded-2xl shadow-sm p-4 md:p-6">
                <div className="flex justify-between mb-4">
                  <h2 className="text-lg font-semibold">Eclectic Leaderboard</h2>
                  <div className="flex gap-2">
                    <button onClick={exportEclecticCSV} className="px-3 py-2 rounded-xl bg-black text-white">Export Eclectic CSV</button>
                  </div>
                </div>
                <div className="overflow-auto">
                  <table className="min-w-full text-sm">
                    <thead>
                      <tr className="border-b text-left">
                        <th>Rank</th><th>Name</th><th>Eclectic Total</th>
                        {Array.from({length:18},(_,i)=>(<th key={i}>H{i+1}</th>))}
                      </tr>
                    </thead>
                    <tbody>
                      {Object.values(season)
                        .sort((a,b)=>( (b.eclecticTotal??0) - (a.eclecticTotal??0) ) || a.name.localeCompare(b.name))
                        .map((r,i)=>(
                        <tr key={r.name} className="border-b">
                          <td>{i+1}</td>
                          <td>{r.name}</td>
                          <td>{r.eclecticTotal??0}</td>
                          {(r.bestPerHole??Array(18).fill(0)).map((v,ix)=>(<td key={ix}>{v}</td>))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                <p className="text-xs text-neutral-500 mt-2">Eclectic = best Stableford per hole (H1–H18) across all uploaded events.</p>
              </section>

              {/* Debug */}
              <section className="bg-white rounded-2xl shadow-sm p-4 md:p-6">
                <h2 className="font-semibold mb-2">Debug Info</h2>
                <p className="text-sm">Supabase URL: {supaURL}</p>
                <p className="text-sm">Players loaded: {players.length}</p>
                <p className="text-sm">Season entries: {Object.keys(season).length}</p>
              </section>
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
